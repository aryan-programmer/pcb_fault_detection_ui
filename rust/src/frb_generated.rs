// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

#![allow(
	non_camel_case_types,
	unused,
	non_snake_case,
	clippy::needless_return,
	clippy::redundant_closure_call,
	clippy::redundant_closure,
	clippy::useless_conversion,
	clippy::unit_arg,
	clippy::unused_unit,
	clippy::double_parens,
	clippy::let_and_return,
	clippy::too_many_arguments,
	clippy::match_single_binding,
	clippy::clone_on_copy,
	clippy::let_unit_value,
	clippy::deref_addrof,
	clippy::explicit_auto_deref,
	clippy::borrow_deref_ref,
	clippy::needless_borrow
)]

// Section: imports

use crate::api::error::*;
use crate::api::model::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
	default_stream_sink_codec = SseCodec,
	default_rust_opaque = RustOpaqueMoi,
	default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.10.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 2037739718;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__error__YoloError_to_string__impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloError_to_string_",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>,
			>>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
						_ => unreachable!(),
					}
				}
				let api_that_guard = api_that_guard.unwrap();
				let output_ok =
					Result::<_, ()>::Ok(crate::api::error::YoloError::to_string_(&*api_that_guard))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_auto_accessor_get_confidence_threshold_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_auto_accessor_get_confidence_threshold",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
						_ => unreachable!(),
					}
				}
				let api_that_guard = api_that_guard.unwrap();
				let output_ok = Result::<_, ()>::Ok(api_that_guard.confidence_threshold.clone())?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_auto_accessor_get_final_metric_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_auto_accessor_get_final_metric",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
						_ => unreachable!(),
					}
				}
				let api_that_guard = api_that_guard.unwrap();
				let output_ok = Result::<_, ()>::Ok(api_that_guard.final_metric.clone())?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_auto_accessor_get_final_metric_threshold_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_auto_accessor_get_final_metric_threshold",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
						_ => unreachable!(),
					}
				}
				let api_that_guard = api_that_guard.unwrap();
				let output_ok = Result::<_, ()>::Ok(api_that_guard.final_metric_threshold.clone())?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_auto_accessor_get_slice_iou_threshold_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_auto_accessor_get_slice_iou_threshold",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
						_ => unreachable!(),
					}
				}
				let api_that_guard = api_that_guard.unwrap();
				let output_ok = Result::<_, ()>::Ok(api_that_guard.slice_iou_threshold.clone())?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_auto_accessor_set_confidence_threshold_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_auto_accessor_set_confidence_threshold",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			let api_confidence_threshold = <f32>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
						_ => unreachable!(),
					}
				}
				let mut api_that_guard = api_that_guard.unwrap();
				let output_ok = Result::<_, ()>::Ok({
					{
						api_that_guard.confidence_threshold = api_confidence_threshold;
					};
				})?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_auto_accessor_set_final_metric_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_auto_accessor_set_final_metric",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			let api_final_metric = <crate::api::utils::MatchMetric>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
						_ => unreachable!(),
					}
				}
				let mut api_that_guard = api_that_guard.unwrap();
				let output_ok = Result::<_, ()>::Ok({
					{
						api_that_guard.final_metric = api_final_metric;
					};
				})?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_auto_accessor_set_final_metric_threshold_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_auto_accessor_set_final_metric_threshold",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			let api_final_metric_threshold = <f32>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
						_ => unreachable!(),
					}
				}
				let mut api_that_guard = api_that_guard.unwrap();
				let output_ok = Result::<_, ()>::Ok({
					{
						api_that_guard.final_metric_threshold = api_final_metric_threshold;
					};
				})?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_auto_accessor_set_slice_iou_threshold_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_auto_accessor_set_slice_iou_threshold",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			let api_slice_iou_threshold = <f32>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let mut api_that_guard = None;
				let decode_indices_ =
					flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
						flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true),
					]);
				for i in decode_indices_ {
					match i {
						0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
						_ => unreachable!(),
					}
				}
				let mut api_that_guard = api_that_guard.unwrap();
				let output_ok = Result::<_, ()>::Ok({
					{
						api_that_guard.slice_iou_threshold = api_slice_iou_threshold;
					};
				})?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__model__YoloModelSession_from_memory_impl(
	port_: flutter_rust_bridge::for_generated::MessagePort,
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_from_memory",
			port: Some(port_),
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_bytes = <crate::api::utils::VecU8Wrapper>::sse_decode(&mut deserializer);
			let api_final_metric = <crate::api::utils::MatchMetric>::sse_decode(&mut deserializer);
			let api_final_metric_threshold = <f32>::sse_decode(&mut deserializer);
			let api_slice_iou_threshold = <f32>::sse_decode(&mut deserializer);
			let api_confidence_threshold = <f32>::sse_decode(&mut deserializer);
			deserializer.end();
			move |context| {
				transform_result_sse::<_, YoloError>((move || {
					let output_ok = crate::api::model::YoloModelSession::from_memory(
						api_bytes,
						api_final_metric,
						api_final_metric_threshold,
						api_slice_iou_threshold,
						api_confidence_threshold,
					)?;
					Ok(output_ok)
				})())
			}
		},
	)
}
fn wire__crate__api__model__YoloModelSession_sliced_inference_impl(
	port_: flutter_rust_bridge::for_generated::MessagePort,
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "YoloModelSession_sliced_inference",
			port: Some(port_),
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <RustOpaqueMoi<
				flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
			>>::sse_decode(&mut deserializer);
			let api_image = <crate::api::utils::VecU8Wrapper>::sse_decode(&mut deserializer);
			let api_image_width = <u32>::sse_decode(&mut deserializer);
			let api_image_height = <u32>::sse_decode(&mut deserializer);
			let api_keep_original = <bool>::sse_decode(&mut deserializer);
			let api_slice_options =
				<Vec<crate::api::slicing::SliceInputParams>>::sse_decode(&mut deserializer);
			deserializer.end();
			move |context| {
				transform_result_sse::<_, YoloError>((move || {
					let mut api_that_guard = None;
					let decode_indices_ =
						flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
							flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false),
						]);
					for i in decode_indices_ {
						match i {
							0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
							_ => unreachable!(),
						}
					}
					let api_that_guard = api_that_guard.unwrap();
					let output_ok = crate::api::model::YoloModelSession::sliced_inference(
						&*api_that_guard,
						api_image,
						api_image_width,
						api_image_height,
						api_keep_original,
						api_slice_options,
					)?;
					Ok(output_ok)
				})())
			}
		},
	)
}
fn wire__crate__api__utils__bounding_box_area_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_area",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok = Result::<_, ()>::Ok(crate::api::utils::BoundingBox::area(&api_that))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_height_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_height",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok = Result::<_, ()>::Ok(crate::api::utils::BoundingBox::height(&api_that))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_intersection_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_intersection",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			let api_box2 = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok = Result::<_, ()>::Ok(crate::api::utils::BoundingBox::intersection(
					&api_that, &api_box2,
				))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_ios_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_ios",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			let api_box2 = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok =
					Result::<_, ()>::Ok(crate::api::utils::BoundingBox::ios(&api_that, &api_box2))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_iou_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_iou",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			let api_box2 = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok =
					Result::<_, ()>::Ok(crate::api::utils::BoundingBox::iou(&api_that, &api_box2))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_is_valid_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_is_valid",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok = Result::<_, ()>::Ok(crate::api::utils::BoundingBox::is_valid(&api_that))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_metric_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_metric",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			let api_box2 = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			let api_metric = <crate::api::utils::MatchMetric>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok = Result::<_, ()>::Ok(crate::api::utils::BoundingBox::metric(
					&api_that, &api_box2, api_metric,
				))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_new_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_new",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_x1 = <u32>::sse_decode(&mut deserializer);
			let api_y1 = <u32>::sse_decode(&mut deserializer);
			let api_x2 = <u32>::sse_decode(&mut deserializer);
			let api_y2 = <u32>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok = Result::<_, ()>::Ok(crate::api::utils::BoundingBox::new(
					api_x1, api_y1, api_x2, api_y2,
				))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_union_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_union",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			let api_box2 = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok =
					Result::<_, ()>::Ok(crate::api::utils::BoundingBox::union(&api_that, &api_box2))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__utils__bounding_box_width_impl(
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "bounding_box_width",
			port: None,
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			let api_that = <crate::api::utils::BoundingBox>::sse_decode(&mut deserializer);
			deserializer.end();
			transform_result_sse::<_, ()>((move || {
				let output_ok = Result::<_, ()>::Ok(crate::api::utils::BoundingBox::width(&api_that))?;
				Ok(output_ok)
			})())
		},
	)
}
fn wire__crate__api__main__init_app_impl(
	port_: flutter_rust_bridge::for_generated::MessagePort,
	ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len_: i32,
	data_len_: i32,
) {
	FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
		flutter_rust_bridge::for_generated::TaskInfo {
			debug_name: "init_app",
			port: Some(port_),
			mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
		},
		move || {
			let message = unsafe {
				flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
					ptr_,
					rust_vec_len_,
					data_len_,
				)
			};
			let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
			deserializer.end();
			move |context| {
				transform_result_sse::<_, ()>((move || {
					let output_ok = Result::<_, ()>::Ok({
						crate::api::main::init_app();
					})?;
					Ok(output_ok)
				})())
			}
		},
	)
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
	flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
	flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>
);

// Section: dart2rust

impl SseDecode for YoloError {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut inner = <RustOpaqueMoi<
			flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>,
		>>::sse_decode(deserializer);
		return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
	}
}

impl SseDecode for YoloModelSession {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut inner = <RustOpaqueMoi<
			flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>,
		>>::sse_decode(deserializer);
		return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
	}
}

impl SseDecode
	for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>>
{
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut inner = <usize>::sse_decode(deserializer);
		return decode_rust_opaque_moi(inner);
	}
}

impl SseDecode
	for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>>
{
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut inner = <usize>::sse_decode(deserializer);
		return decode_rust_opaque_moi(inner);
	}
}

impl SseDecode for String {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut inner = <Vec<u8>>::sse_decode(deserializer);
		return String::from_utf8(inner).unwrap();
	}
}

impl SseDecode for bool {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		deserializer.cursor.read_u8().unwrap() != 0
	}
}

impl SseDecode for crate::api::utils::BoundingBox {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut var_x1 = <u32>::sse_decode(deserializer);
		let mut var_y1 = <u32>::sse_decode(deserializer);
		let mut var_x2 = <u32>::sse_decode(deserializer);
		let mut var_y2 = <u32>::sse_decode(deserializer);
		return crate::api::utils::BoundingBox {
			x1: var_x1,
			y1: var_y1,
			x2: var_x2,
			y2: var_y2,
		};
	}
}

impl SseDecode for f32 {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		deserializer.cursor.read_f32::<NativeEndian>().unwrap()
	}
}

impl SseDecode for i32 {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		deserializer.cursor.read_i32::<NativeEndian>().unwrap()
	}
}

impl SseDecode for Vec<u8> {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut len_ = <i32>::sse_decode(deserializer);
		let mut ans_ = vec![];
		for idx_ in 0..len_ {
			ans_.push(<u8>::sse_decode(deserializer));
		}
		return ans_;
	}
}

impl SseDecode for Vec<crate::api::slicing::SliceInputParams> {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut len_ = <i32>::sse_decode(deserializer);
		let mut ans_ = vec![];
		for idx_ in 0..len_ {
			ans_.push(<crate::api::slicing::SliceInputParams>::sse_decode(
				deserializer,
			));
		}
		return ans_;
	}
}

impl SseDecode for Vec<crate::api::utils::YoloEntityOutput> {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut len_ = <i32>::sse_decode(deserializer);
		let mut ans_ = vec![];
		for idx_ in 0..len_ {
			ans_.push(<crate::api::utils::YoloEntityOutput>::sse_decode(
				deserializer,
			));
		}
		return ans_;
	}
}

impl SseDecode for crate::api::utils::MatchMetric {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut inner = <i32>::sse_decode(deserializer);
		return match inner {
			0 => crate::api::utils::MatchMetric::IOU,
			1 => crate::api::utils::MatchMetric::IOS,
			_ => unreachable!("Invalid variant for MatchMetric: {}", inner),
		};
	}
}

impl SseDecode for crate::api::slicing::SliceInputParams {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut var_sliceWidth = <u32>::sse_decode(deserializer);
		let mut var_sliceHeight = <u32>::sse_decode(deserializer);
		let mut var_overlapWidthRatio = <f32>::sse_decode(deserializer);
		let mut var_overlapHeightRatio = <f32>::sse_decode(deserializer);
		return crate::api::slicing::SliceInputParams {
			slice_width: var_sliceWidth,
			slice_height: var_sliceHeight,
			overlap_width_ratio: var_overlapWidthRatio,
			overlap_height_ratio: var_overlapHeightRatio,
		};
	}
}

impl SseDecode for u32 {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		deserializer.cursor.read_u32::<NativeEndian>().unwrap()
	}
}

impl SseDecode for u8 {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		deserializer.cursor.read_u8().unwrap()
	}
}

impl SseDecode for () {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
	}
}

impl SseDecode for crate::api::utils::VecU8Wrapper {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut var_v = <Vec<u8>>::sse_decode(deserializer);
		return crate::api::utils::VecU8Wrapper { v: var_v };
	}
}

impl SseDecode for crate::api::utils::YoloEntityOutput {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
		let mut var_boundingBox = <crate::api::utils::BoundingBox>::sse_decode(deserializer);
		let mut var_classId = <u8>::sse_decode(deserializer);
		let mut var_confidence = <f32>::sse_decode(deserializer);
		return crate::api::utils::YoloEntityOutput {
			bounding_box: var_boundingBox,
			class_id: var_classId,
			confidence: var_confidence,
		};
	}
}

fn pde_ffi_dispatcher_primary_impl(
	func_id: i32,
	port: flutter_rust_bridge::for_generated::MessagePort,
	ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len: i32,
	data_len: i32,
) {
	// Codec=Pde (Serialization + dispatch), see doc to use other codecs
	match func_id {
		10 => {
			wire__crate__api__model__YoloModelSession_from_memory_impl(port, ptr, rust_vec_len, data_len)
		}
		11 => wire__crate__api__model__YoloModelSession_sliced_inference_impl(
			port,
			ptr,
			rust_vec_len,
			data_len,
		),
		22 => wire__crate__api__main__init_app_impl(port, ptr, rust_vec_len, data_len),
		_ => unreachable!(),
	}
}

fn pde_ffi_dispatcher_sync_impl(
	func_id: i32,
	ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
	rust_vec_len: i32,
	data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
	// Codec=Pde (Serialization + dispatch), see doc to use other codecs
	match func_id {
		1 => wire__crate__api__error__YoloError_to_string__impl(ptr, rust_vec_len, data_len),
		2 => wire__crate__api__model__YoloModelSession_auto_accessor_get_confidence_threshold_impl(
			ptr,
			rust_vec_len,
			data_len,
		),
		3 => wire__crate__api__model__YoloModelSession_auto_accessor_get_final_metric_impl(
			ptr,
			rust_vec_len,
			data_len,
		),
		4 => wire__crate__api__model__YoloModelSession_auto_accessor_get_final_metric_threshold_impl(
			ptr,
			rust_vec_len,
			data_len,
		),
		5 => wire__crate__api__model__YoloModelSession_auto_accessor_get_slice_iou_threshold_impl(
			ptr,
			rust_vec_len,
			data_len,
		),
		6 => wire__crate__api__model__YoloModelSession_auto_accessor_set_confidence_threshold_impl(
			ptr,
			rust_vec_len,
			data_len,
		),
		7 => wire__crate__api__model__YoloModelSession_auto_accessor_set_final_metric_impl(
			ptr,
			rust_vec_len,
			data_len,
		),
		8 => wire__crate__api__model__YoloModelSession_auto_accessor_set_final_metric_threshold_impl(
			ptr,
			rust_vec_len,
			data_len,
		),
		9 => wire__crate__api__model__YoloModelSession_auto_accessor_set_slice_iou_threshold_impl(
			ptr,
			rust_vec_len,
			data_len,
		),
		12 => wire__crate__api__utils__bounding_box_area_impl(ptr, rust_vec_len, data_len),
		13 => wire__crate__api__utils__bounding_box_height_impl(ptr, rust_vec_len, data_len),
		14 => wire__crate__api__utils__bounding_box_intersection_impl(ptr, rust_vec_len, data_len),
		15 => wire__crate__api__utils__bounding_box_ios_impl(ptr, rust_vec_len, data_len),
		16 => wire__crate__api__utils__bounding_box_iou_impl(ptr, rust_vec_len, data_len),
		17 => wire__crate__api__utils__bounding_box_is_valid_impl(ptr, rust_vec_len, data_len),
		18 => wire__crate__api__utils__bounding_box_metric_impl(ptr, rust_vec_len, data_len),
		19 => wire__crate__api__utils__bounding_box_new_impl(ptr, rust_vec_len, data_len),
		20 => wire__crate__api__utils__bounding_box_union_impl(ptr, rust_vec_len, data_len),
		21 => wire__crate__api__utils__bounding_box_width_impl(ptr, rust_vec_len, data_len),
		_ => unreachable!(),
	}
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<YoloError> {
	fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
		flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
	}
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<YoloError> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<YoloError>> for YoloError {
	fn into_into_dart(self) -> FrbWrapper<YoloError> {
		self.into()
	}
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<YoloModelSession> {
	fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
		flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
	}
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<YoloModelSession> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<YoloModelSession>> for YoloModelSession {
	fn into_into_dart(self) -> FrbWrapper<YoloModelSession> {
		self.into()
	}
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::utils::BoundingBox {
	fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
		[
			self.x1.into_into_dart().into_dart(),
			self.y1.into_into_dart().into_dart(),
			self.x2.into_into_dart().into_dart(),
			self.y2.into_into_dart().into_dart(),
		]
		.into_dart()
	}
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
	for crate::api::utils::BoundingBox
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::utils::BoundingBox>
	for crate::api::utils::BoundingBox
{
	fn into_into_dart(self) -> crate::api::utils::BoundingBox {
		self
	}
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::utils::MatchMetric {
	fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
		match self {
			Self::IOU => 0.into_dart(),
			Self::IOS => 1.into_dart(),
			_ => unreachable!(),
		}
	}
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
	for crate::api::utils::MatchMetric
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::utils::MatchMetric>
	for crate::api::utils::MatchMetric
{
	fn into_into_dart(self) -> crate::api::utils::MatchMetric {
		self
	}
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::slicing::SliceInputParams {
	fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
		[
			self.slice_width.into_into_dart().into_dart(),
			self.slice_height.into_into_dart().into_dart(),
			self.overlap_width_ratio.into_into_dart().into_dart(),
			self.overlap_height_ratio.into_into_dart().into_dart(),
		]
		.into_dart()
	}
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
	for crate::api::slicing::SliceInputParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::slicing::SliceInputParams>
	for crate::api::slicing::SliceInputParams
{
	fn into_into_dart(self) -> crate::api::slicing::SliceInputParams {
		self
	}
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::utils::VecU8Wrapper {
	fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
		[self.v.into_into_dart().into_dart()].into_dart()
	}
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
	for crate::api::utils::VecU8Wrapper
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::utils::VecU8Wrapper>
	for crate::api::utils::VecU8Wrapper
{
	fn into_into_dart(self) -> crate::api::utils::VecU8Wrapper {
		self
	}
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::utils::YoloEntityOutput {
	fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
		[
			self.bounding_box.into_into_dart().into_dart(),
			self.class_id.into_into_dart().into_dart(),
			self.confidence.into_into_dart().into_dart(),
		]
		.into_dart()
	}
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
	for crate::api::utils::YoloEntityOutput
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::utils::YoloEntityOutput>
	for crate::api::utils::YoloEntityOutput
{
	fn into_into_dart(self) -> crate::api::utils::YoloEntityOutput {
		self
	}
}

impl SseEncode for YoloError {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>>>::sse_encode(
			flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
			serializer,
		);
	}
}

impl SseEncode for YoloModelSession {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
	}
}

impl SseEncode
	for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>>
{
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		let (ptr, size) = self.sse_encode_raw();
		<usize>::sse_encode(ptr, serializer);
		<i32>::sse_encode(size, serializer);
	}
}

impl SseEncode
	for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>>
{
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		let (ptr, size) = self.sse_encode_raw();
		<usize>::sse_encode(ptr, serializer);
		<i32>::sse_encode(size, serializer);
	}
}

impl SseEncode for String {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<Vec<u8>>::sse_encode(self.into_bytes(), serializer);
	}
}

impl SseEncode for bool {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		serializer.cursor.write_u8(self as _).unwrap();
	}
}

impl SseEncode for crate::api::utils::BoundingBox {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<u32>::sse_encode(self.x1, serializer);
		<u32>::sse_encode(self.y1, serializer);
		<u32>::sse_encode(self.x2, serializer);
		<u32>::sse_encode(self.y2, serializer);
	}
}

impl SseEncode for f32 {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
	}
}

impl SseEncode for i32 {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
	}
}

impl SseEncode for Vec<u8> {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<i32>::sse_encode(self.len() as _, serializer);
		for item in self {
			<u8>::sse_encode(item, serializer);
		}
	}
}

impl SseEncode for Vec<crate::api::slicing::SliceInputParams> {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<i32>::sse_encode(self.len() as _, serializer);
		for item in self {
			<crate::api::slicing::SliceInputParams>::sse_encode(item, serializer);
		}
	}
}

impl SseEncode for Vec<crate::api::utils::YoloEntityOutput> {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<i32>::sse_encode(self.len() as _, serializer);
		for item in self {
			<crate::api::utils::YoloEntityOutput>::sse_encode(item, serializer);
		}
	}
}

impl SseEncode for crate::api::utils::MatchMetric {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<i32>::sse_encode(
			match self {
				crate::api::utils::MatchMetric::IOU => 0,
				crate::api::utils::MatchMetric::IOS => 1,
				_ => {
					unimplemented!("");
				}
			},
			serializer,
		);
	}
}

impl SseEncode for crate::api::slicing::SliceInputParams {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<u32>::sse_encode(self.slice_width, serializer);
		<u32>::sse_encode(self.slice_height, serializer);
		<f32>::sse_encode(self.overlap_width_ratio, serializer);
		<f32>::sse_encode(self.overlap_height_ratio, serializer);
	}
}

impl SseEncode for u32 {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
	}
}

impl SseEncode for u8 {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		serializer.cursor.write_u8(self).unwrap();
	}
}

impl SseEncode for () {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		serializer
			.cursor
			.write_u64::<NativeEndian>(self as _)
			.unwrap();
	}
}

impl SseEncode for crate::api::utils::VecU8Wrapper {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<Vec<u8>>::sse_encode(self.v, serializer);
	}
}

impl SseEncode for crate::api::utils::YoloEntityOutput {
	// Codec=Sse (Serialization based), see doc to use other codecs
	fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
		<crate::api::utils::BoundingBox>::sse_encode(self.bounding_box, serializer);
		<u8>::sse_encode(self.class_id, serializer);
		<f32>::sse_encode(self.confidence, serializer);
	}
}

#[cfg(not(target_family = "wasm"))]
mod io {
	// This file is automatically generated, so please do not edit it.
	// @generated by `flutter_rust_bridge`@ 2.10.0.

	// Section: imports

	use super::*;
	use crate::api::error::*;
	use crate::api::model::*;
	use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
	use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
	use flutter_rust_bridge::{Handler, IntoIntoDart};

	// Section: boilerplate

	flutter_rust_bridge::frb_generated_boilerplate_io!();

	#[unsafe(no_mangle)]
	pub extern "C" fn frbgen_pcb_fault_detection_ui_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerYoloError(
		ptr: *const std::ffi::c_void,
	) {
		MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>>::increment_strong_count(ptr as _);
	}

	#[unsafe(no_mangle)]
	pub extern "C" fn frbgen_pcb_fault_detection_ui_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerYoloError(
		ptr: *const std::ffi::c_void,
	) {
		MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>>::decrement_strong_count(ptr as _);
	}

	#[unsafe(no_mangle)]
	pub extern "C" fn frbgen_pcb_fault_detection_ui_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerYoloModelSession(
		ptr: *const std::ffi::c_void,
	) {
		MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>>::increment_strong_count(ptr as _);
	}

	#[unsafe(no_mangle)]
	pub extern "C" fn frbgen_pcb_fault_detection_ui_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerYoloModelSession(
		ptr: *const std::ffi::c_void,
	) {
		MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>>::decrement_strong_count(ptr as _);
	}
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
	// This file is automatically generated, so please do not edit it.
	// @generated by `flutter_rust_bridge`@ 2.10.0.

	// Section: imports

	use super::*;
	use crate::api::error::*;
	use crate::api::model::*;
	use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
	use flutter_rust_bridge::for_generated::wasm_bindgen;
	use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
	use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
	use flutter_rust_bridge::{Handler, IntoIntoDart};

	// Section: boilerplate

	flutter_rust_bridge::frb_generated_boilerplate_web!();

	#[wasm_bindgen]
	pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerYoloError(
		ptr: *const std::ffi::c_void,
	) {
		MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>>::increment_strong_count(ptr as _);
	}

	#[wasm_bindgen]
	pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerYoloError(
		ptr: *const std::ffi::c_void,
	) {
		MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloError>>::decrement_strong_count(ptr as _);
	}

	#[wasm_bindgen]
	pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerYoloModelSession(
		ptr: *const std::ffi::c_void,
	) {
		MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>>::increment_strong_count(ptr as _);
	}

	#[wasm_bindgen]
	pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerYoloModelSession(
		ptr: *const std::ffi::c_void,
	) {
		MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YoloModelSession>>::decrement_strong_count(ptr as _);
	}
}
#[cfg(target_family = "wasm")]
pub use web::*;
