// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'utils.freezed.dart';
part 'utils.g.dart';

// These functions are ignored because they are not marked as `pub`: `new_with_log`, `new`, `non_maximum_suppression_with_sorted_boxes`, `non_maximum_suppression`, `sort_predictions`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `DropTimer`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `drop`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `non_maximum_suppression_collect`, `non_maximum_suppression_collect`

@freezed
sealed class BoundingBox with _$BoundingBox {
  const BoundingBox._();
  const factory BoundingBox.raw({
    required int x1,
    required int y1,
    required int x2,
    required int y2,
  }) = _BoundingBox;
  double area() =>
      RustLib.instance.api.crateApiUtilsBoundingBoxArea(that: this);

  int height() =>
      RustLib.instance.api.crateApiUtilsBoundingBoxHeight(that: this);

  double intersection({required BoundingBox box2}) => RustLib.instance.api
      .crateApiUtilsBoundingBoxIntersection(that: this, box2: box2);

  double ios({required BoundingBox box2}) =>
      RustLib.instance.api.crateApiUtilsBoundingBoxIos(that: this, box2: box2);

  double iou({required BoundingBox box2}) =>
      RustLib.instance.api.crateApiUtilsBoundingBoxIou(that: this, box2: box2);

  bool isValid() =>
      RustLib.instance.api.crateApiUtilsBoundingBoxIsValid(that: this);

  double metric({required BoundingBox box2, required MatchMetric metric}) =>
      RustLib.instance.api.crateApiUtilsBoundingBoxMetric(
        that: this,
        box2: box2,
        metric: metric,
      );

  factory BoundingBox({
    required int x1,
    required int y1,
    required int x2,
    required int y2,
  }) => RustLib.instance.api.crateApiUtilsBoundingBoxNew(
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2,
  );

  double union({required BoundingBox box2}) => RustLib.instance.api
      .crateApiUtilsBoundingBoxUnion(that: this, box2: box2);

  int width() => RustLib.instance.api.crateApiUtilsBoundingBoxWidth(that: this);

  factory BoundingBox.fromJson(Map<String, dynamic> json) =>
      _$BoundingBoxFromJson(json);
}

enum MatchMetric { iou, ios }

class VecU8Wrapper {
  final Uint8List v;

  const VecU8Wrapper({required this.v});

  @override
  int get hashCode => v.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VecU8Wrapper && runtimeType == other.runtimeType && v == other.v;
}

@freezed
sealed class YoloEntityOutput with _$YoloEntityOutput {
  const factory YoloEntityOutput({
    required BoundingBox boundingBox,
    required int classId,
    required double confidence,
  }) = _YoloEntityOutput;

  factory YoloEntityOutput.fromJson(Map<String, dynamic> json) =>
      _$YoloEntityOutputFromJson(json);
}
